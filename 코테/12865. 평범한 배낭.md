### 문제
https://www.acmicpc.net/problem/12865

### 참고
https://claude-u.tistory.com/208

### 코드(복붙)
```py
import sys

N, K = map(int, input().split())
stuff = [[0,0]]
knapsack = [[0 for _ in range(K + 1)] for _ in range(N + 1)]

for _ in range(N):
    stuff.append(list(map(int, input().split())))


#냅색 문제 풀이
for i in range(1, N + 1):
    for j in range(1, K + 1):
        weight = stuff[i][0] 
        value = stuff[i][1]
       
        if j < weight:
            knapsack[i][j] = knapsack[i - 1][j] #weight보다 작으면 위의 값을 그대로 가져온다
        else:
            knapsack[i][j] = max(value + knapsack[i - 1][j - weight], knapsack[i - 1][j])

print(knapsack[N][K])
```

### 문제 해설
쪼갤 수 없는 배냥 문제이다. 다이나믹 프로그래밍을 활용하여 풀수 있다.

물건을 순서대로 비교하며 찾는다.<br>
들수 있는 무게를 1씩 늘리며 찾는데<br>
만일 들수 없는 무게이면 전에 비교한 물건의 무게값을 가져온다.<br>
들수 있는 무게이면 전 물건의 여분 무게 값 + 현제 물건 값과 전 물건 값을 비교하여 높은 것을 선택한다.