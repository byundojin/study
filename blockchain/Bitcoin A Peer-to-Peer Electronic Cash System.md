### 요약
순수한 개인 간 전자화폐시스템으로도 개인 대 개인 온라인 지불이 가능함.<br>
이 논문에서 이중 지불 문제에 대한 해결책을 제시함

### 서론
#### 상황
기존의 인터넷 상거래 - 금융기관의 의존 -> 신뢰를 기반한 거래

기존 금융기관 - 철회가 불가능한 거래 x<br>
-> 더 많은 신용 요구, 거래 비용 증가

#### 필요
신뢰 기반 -> 암호학적 증명 기반

건전한 노드의 cpu파워 > 공격자의 cpu파워 일때 안전하게 동작

### 거래
전자 코인 -> 디지털 서명의 체인

이전 거래의 해쉬와 받는 이의 공개키의 대해 디지털 서명 후 코인의 끝의 붙여서 전송<br>
-> 받는 이는 서명에 대한 검증을 통해 소유권 확인

코인 중복 사용 문제 해결
1. 모든 거래 내역 인지
2. 거래 내역 공개
3. 노드들의 합의 증거(이 거래가 처음 거래임을 증명하는)

### 타임스탬프 서버
블록체인 타임스탬프 -> 암호학을 이용한 논리적 타임스탬프

타임스탬프 -> 데이터 입력 값 보증

### 작업 증명
공격자를 막기위한 블록 증명

nonce - 블록 해시 결과가 요구한 연속된 0비트 수에 만족하는 값

작업증명 - nonce값을 찾는 과정

블록을 수정하려면 이후 모든 블록의 관한 작업증명을 다시 해야함<br>
-> 공격자가 블록을 수정하지 못하게 함

### 네트워크
네크워크의 동작 과정
1) 새로운 거래들은 모든 노드에 브로드캐스트된다. 
2) 각 노드는 새로운 거래들을 모아 블록에 넣는다. 
3) 각 노드는 해당 블록에 대한 작업증명을 찾는 과정을 수행한다. 
4) 어떤 노드가 작업증명을 찾았다면, 해당 블록을 모든 노드에게 브로드캐스트한다. 
5) 노드들은, 브로드캐스트 받은 블록에 대해서, 블록 내 모든 거래가 유효하고 중복 사용되
지 않았을 때, 해당 블록을 승인한다. 
6) 노드들은, 그들이 해당 블록을 승인했다는 것을, 해당 블록의 해시를 이용해서 그다음 블록생성을 시작함으로써 암묵적으로 나타낸다.

블록체인은 항상 긴 체인을 우선으로 한다.<br>
만일 두 블록이 동시에 생성된다면 블록당 분기가 나누어 지며 우선적으로 전달 받은 것을 작업한다.<br>
만일 다른 분기의 체인 길이가 작업하던 체인 길이를 넘어선다면 작업하던 것을 멈춘 후 길이가 긴 체인을 작업한다.

### 인센티브
블록의 포함된 첫 번째 거래<br>
-> 해당 블록 생성자에게 새로운 코인이 발행되는 특별한 거래

거래수수료도 인센티브에 포함됨

만일 코인이 어느정도 풀리게 되면 인플레이션 방지를 위해 코인 발행 중단<br>
-> 거래수수료만으로 인센티브 지급

이는 공격자가 막강한 cpu파워를 가지고 자신의 부와 함께 시스템을 붕괴하는 것 보다, 시스템의 규칙하에 신규코인을 얻는 것이 이득이라는 선택압을 줌

### 디스크 공간 회수
코인에 대한 가장 최근 거래가 충분한 수의 블록에 묻힌다면, 디스크 절약을 위해 이전 거래 기록을 삭제해도 됨

### 간소화된 지불 검증
네트워크의 가장긴 체인의 복사본과 거래의 대해 타임스탬핑된 블록을 통하여 머클트리의 가지 획득가능<br>
-> 네트워크가 해당 거래를 받아 드렸고, 해당 거래 이후 다른 블록이 이어짐<br>
-> 네트워크가 거래를 승인함

노드는 스스로 거래 검증 가능<br>
간소화된 방법은 조작된 거래의 농락당함<br>
->공격자의 파워가 더 큰 경우 매우 취약함

노드가 잘못된 블록을 발견시 경고를 보냄
-> 잘못된 블록과 거래를 받아 불일치 확인

### 금액의 결합과 분할
거래는 복수의 입금과 2개의 출금으로 구성됨
2개의 출금중 하나는 지불할 금액이고 다른 하나는 잔액이며 잔액은 자신에게 보내진다.

### 프라이버시
개인의 공개키가 익명화되어 정보 추적을 막음
-> 개인의 프라이버시를 보호

거래 자체는 공유됨 but 거래의 당사자는 알 수 없음

### 계산
나중에

### 결론
정직한 노드들이 대부분의cpu파워를 가지는 한 공격은 불가능에 가까움

